### **1\. Características de GNU/Linux**

1. Mencione y explique las características más relevantes de GNU/Linux.

    1\. Software Libre y de Código Abierto

   1. **Licencia GPL**: GNU/Linux se distribuye bajo la Licencia Pública General de GNU (GPL), que permite a los usuarios ejecutar, estudiar, compartir y modificar el software. Esto fomenta la colaboración y el desarrollo comunitario.  
   2. **Código Abierto**: El código fuente está disponible para que cualquiera lo examine, lo que permite una transparencia total en su funcionamiento y seguridad.

2\. Multiplataforma

3. **Compatibilidad**: GNU/Linux es compatible con una amplia variedad de arquitecturas de hardware, desde servidores y supercomputadoras hasta dispositivos móviles y embebidos.  
   4. **Adaptabilidad**: Se puede ejecutar en hardware antiguo, lo que extiende la vida útil de equipos que ya no son compatibles con otros sistemas operativos modernos.

3\. Estabilidad y Robustez

5. **Fiabilidad**: GNU/Linux es conocido por su estabilidad, especialmente en entornos de servidor. Muchos servidores web y supercomputadoras utilizan GNU/Linux debido a su capacidad para operar de manera continua sin necesidad de reinicios frecuentes.  
   6. **Gestión de Recursos**: Maneja eficientemente los recursos del sistema, lo que lo hace ideal para tareas que requieren alta disponibilidad y rendimiento.

4\. Seguridad

7. **Sistema de Permisos**: GNU/Linux utiliza un sistema de permisos y usuarios que ayuda a proteger el sistema contra accesos no autorizados.  
   8. **Actualizaciones Rápidas**: La comunidad de desarrolladores responde rápidamente a las vulnerabilidades de seguridad, proporcionando parches y actualizaciones frecuentes.

5\. Personalización

9. **Entornos de Escritorio**: Los usuarios pueden elegir entre una variedad de entornos de escritorio, como GNOME, KDE, XFCE, entre otros, que ofrecen diferentes niveles de personalización y funcionalidades.  
   10. **Configuración Flexible**: Casi todos los aspectos del sistema se pueden configurar y personalizar para adaptarse a las necesidades del usuario, desde la apariencia visual hasta el comportamiento del sistema.

6\. Gestión de Paquetes

11. **Repositorios de Software**: GNU/Linux utiliza gestores de paquetes como `apt` (Debian/Ubuntu), `dnf` (Fedora), y `pacman` (Arch Linux), que facilitan la instalación, actualización y eliminación de software.  
    12. **Control de Dependencias**: Estos gestores de paquetes manejan automáticamente las dependencias entre aplicaciones, simplificando el mantenimiento del sistema.

7\. Multitarea y Multiusuario

13. **Capacidades Multitarea**: GNU/Linux permite ejecutar múltiples procesos al mismo tiempo sin afectar el rendimiento general del sistema.  
    14. **Sistema Multiusuario**: Varios usuarios pueden trabajar en el mismo sistema simultáneamente, cada uno con su propio entorno y permisos.

8\. Comunidad y Soporte

15. **Documentación Extensa**: Hay una gran cantidad de documentación, foros, y wikis que proporcionan soporte gratuito y compartido por la comunidad.  
    16. **Distribuciones Diversas**: Existen numerosas distribuciones (distros) de GNU/Linux, cada una adaptada a diferentes usos, como Ubuntu, Fedora, Debian, Arch Linux, entre otras.

9\. Eficiencia Energética

17. **Ahorro de Energía**: GNU/Linux incluye herramientas y configuraciones para optimizar el consumo de energía, lo que es útil tanto en dispositivos móviles como en servidores.

10\. Desarrollo y Programación

18. **Herramientas de Desarrollo**: GNU/Linux ofrece un entorno ideal para la programación y el desarrollo de software, con un amplio conjunto de herramientas y lenguajes de programación disponibles de manera nativa.  
    19. **Compatibilidad con Contenedores**: Es compatible con tecnologías como Docker y Kubernetes, lo que lo convierte en una elección popular para el desarrollo y despliegue de aplicaciones en contenedores.

Mencione otros sistemas operativos y compárelos con GNU/Linux en cuanto a los puntos mencionados en el inciso a.

 	1\. Software Libre y de Código Abierto

20. **Windows**: Es un software propietario desarrollado por Microsoft. El código fuente no está disponible para los usuarios, lo que limita la transparencia y personalización.  
    21. **macOS**: También es un software propietario desarrollado por Apple. Aunque algunas partes (como el kernel XNU) tienen componentes de código abierto, la mayor parte del sistema es cerrado.  
    22. **BSD (FreeBSD, OpenBSD, etc.)**: Al igual que GNU/Linux, es de código abierto y licenciado bajo licencias BSD, que son más permisivas que la GPL. Sin embargo, las licencias BSD permiten que el código fuente sea incorporado en software propietario sin obligación de liberar el código fuente modificado.

2\. Multiplataforma

23. **Windows**: Principalmente utilizado en arquitecturas x86 y x64, aunque hay versiones para ARM, no tiene la misma versatilidad en cuanto a la variedad de hardware soportado comparado con GNU/Linux.  
    24. **macOS**: Funciona principalmente en hardware Apple (arquitecturas x64 y ARM), lo que limita su uso a dispositivos diseñados por Apple.  
    25. **BSD**: Soporta varias arquitecturas, aunque su compatibilidad con hardware moderno es más limitada en comparación con GNU/Linux. BSD es popular en servidores y sistemas embebidos.

3\. Estabilidad y Robustez

26. **Windows**: Aunque Windows 10 y 11 han mejorado en términos de estabilidad, históricamente no ha sido tan estable como GNU/Linux en entornos de servidor. Los reinicios frecuentes son comunes debido a actualizaciones.  
    27. **macOS**: Conocido por ser estable y optimizado, especialmente en hardware Apple. Sin embargo, en entornos de servidor, no es tan popular como GNU/Linux.  
    28. **BSD**: Considerado muy estable, especialmente en entornos de servidor. BSD es conocido por su seguridad y fiabilidad, similar a GNU/Linux, aunque con menos soporte de software.

4\. Seguridad

29. **Windows**: Aunque ha mejorado con versiones recientes, sigue siendo un objetivo frecuente de malware debido a su popularidad. El sistema de permisos y usuarios no es tan robusto como en GNU/Linux.  
    30. **macOS**: Generalmente se considera seguro, pero sigue siendo propietario, lo que limita la transparencia. Apple controla las actualizaciones de seguridad.  
    31. **BSD**: Conocido por su enfoque en la seguridad, especialmente OpenBSD. Ofrece un sistema de permisos y usuarios similar a GNU/Linux, con un enfoque más conservador en la seguridad.

5\. Personalización

32. **Windows**: Ofrece opciones de personalización, pero muchas están limitadas en comparación con GNU/Linux. Las configuraciones más profundas suelen requerir herramientas de terceros.  
    33. **macOS**: Tiene una interfaz de usuario altamente pulida, pero es menos personalizable que GNU/Linux. Apple mantiene un control estricto sobre el entorno de escritorio.  
    34. **BSD**: Ofrece un nivel de personalización similar a GNU/Linux, pero con menos opciones en cuanto a entornos de escritorio y software de terceros.

6\. Gestión de Paquetes

35. **Windows**: No tiene un gestor de paquetes nativo comparable con GNU/Linux. La instalación de software se realiza generalmente a través de ejecutables descargados, aunque PowerShell y Chocolatey ofrecen capacidades similares.  
    36. **macOS**: Usa la App Store para la mayoría del software, pero también se pueden utilizar gestores de paquetes como Homebrew, que ofrecen una experiencia más cercana a la de GNU/Linux.  
    37. **BSD**: Usa su propio sistema de gestión de paquetes (por ejemplo, `pkg` en FreeBSD), que es comparable al de GNU/Linux en términos de funcionalidad, aunque con un repositorio más pequeño.

7\. Multitarea y Multiusuario

38. **Windows**: Ofrece multitarea y capacidades multiusuario, pero tradicionalmente ha estado más enfocado en el usuario único, especialmente en ediciones para consumidores.  
    39. **macOS**: También ofrece multitarea y capacidades multiusuario, con un enfoque en la simplicidad y la experiencia de usuario.  
    40. **BSD**: Ofrece multitarea y soporte multiusuario robusto, similar a GNU/Linux, y es utilizado en entornos de servidor y como sistema operativo principal en sistemas de red.

8\. Comunidad y Soporte

41. **Windows**: Tiene un soporte comercial fuerte de Microsoft, con una gran cantidad de documentación oficial, pero la comunidad no es tan abierta como la de GNU/Linux.  
    42. **macOS**: Soporte fuerte por parte de Apple, pero la comunidad de usuarios no es tan grande ni tan activa como la de GNU/Linux. Gran parte del soporte es a través de AppleCare.  
    43. **BSD**: Tiene una comunidad más pequeña y especializada que GNU/Linux. La documentación es buena, pero hay menos recursos disponibles en comparación con GNU/Linux.

9\. Eficiencia Energética

44. **Windows**: Las versiones recientes han mejorado en términos de eficiencia energética, pero sigue siendo menos optimizado que GNU/Linux en hardware antiguo o específico.  
    45. **macOS**: Está altamente optimizado para hardware Apple, ofreciendo excelente eficiencia energética en dispositivos como MacBooks.  
    46. **BSD**: Ofrece buena eficiencia energética, pero puede requerir más configuración manual en comparación con GNU/Linux.

10\. Desarrollo y Programación

47. **Windows**: Es una buena plataforma para desarrollo, especialmente con la integración de WSL (Windows Subsystem for Linux), pero no tiene la misma flexibilidad que GNU/Linux.  
    48. **macOS**: Popular entre desarrolladores, especialmente en el desarrollo de software para iOS y macOS. Ofrece una terminal UNIX y herramientas como Xcode.  
    49. **BSD**: Muy usado en servidores y redes, y popular en ciertos nichos como el desarrollo de sistemas operativos. Sin embargo, el soporte para herramientas modernas puede ser más limitado.  
2. ¿Qué es GNU?

    El sistema GNU es el sistema operativo similar a Unix, constituido en su totalidad por software libre. Un sistema operativo similar a Unix está constituido por muchos programas. El sistema GNU incluye todo el software GNU, además de muchos otros paquetes, como el sistema X Window y TeX, los cuales no son software de GNU.

3. Indique una breve historia sobre la evolución del proyecto GNU

    En 1985, Richard Stallman creó la Free Software Foundation (FSF o Fundación para el Software Libre) para proveer soportes logísticos, legales y financieros al proyecto GNU. La FSF también contrató programadores para contribuir a GNU, aunque una porción sustancial del desarrollo fue (y continúa siendo) producida por voluntarios. En 1990, el sistema GNU ya tenía un editor de texto llamado Emacs, un exitoso compilador (GCC),

4. Explique qué es la multitarea, e indique si GNU/Linux hace uso de ella.

    La multitarea es la capacidad de un sistema operativo para ejecutar múltiples procesos o tareas al mismo tiempo. En un sistema multitarea, varias aplicaciones o procesos pueden estar en ejecución simultáneamente, y el sistema operativo se encarga de gestionar los recursos del hardware (como CPU, memoria, y disco) para que estos procesos se ejecuten sin interferirse entre sí.

    Sí, GNU/Linux utiliza multitarea preventiva. Este enfoque permite que múltiples procesos se ejecuten "simultáneamente", dando la impresión de que todos están activos al mismo tiempo, aunque realmente el CPU está cambiando rápidamente entre ellos.

5. ¿Qué es POSIX?

    POSIX (Portable Operating System Interface) es un conjunto de estándares definidos por IEEE (Instituto de Ingenieros Eléctricos y Electrónicos) que especifican una interfaz común para los sistemas operativos. Estos estándares están diseñados para garantizar la compatibilidad y portabilidad del software entre diferentes sistemas operativos, principalmente los que son similares a UNIX, como GNU/Linux, macOS, y otros sistemas basados en UNIX.

### **2\. Distribuciones de GNU/Linux**

1. ¿Qué es una distribución de GNU/Linux? Nombre al menos 4 distribuciones de GNU/- Linux y cite diferencias básicas entre ellas.

    Una distribución Linux o distribución GNU/Linux (abreviada con frecuencia distro) es un conjunto de aplicaciones reunidas que permiten brindar mejoras para instalar fácilmente un sistema operativo basado en GNU/Linux. Son "sabores" de GNU/Linux que, en general, se diferencian entre sí por las herramientas para configuración y sistemas de administración de paquetes de software para instalar. La elección de una distribución depende de las necesidades del usuario y de gustos personales.

    Ejemplos: Ubuntu, debian, Fedora, Red Hat Linux, etc.

   * **Debian**  
     * Es conocido por su estabilidad, compromiso con el software libre, y es la base de muchas otras distribuciones, incluyendo Ubuntu.  
   * **Ubuntu**  
     * Derivado de Debian, está diseñado para ser fácil de usar, con un enfoque en la accesibilidad y la facilidad de uso para el usuario final. Es popular tanto en escritorios como en servidores.  
   * **Fedora**  
     * **Propósito**: Se enfoca en ser una distribución de vanguardia, ofreciendo las últimas tecnologías y actualizaciones rápidas, sirviendo como un campo de pruebas para Red Hat Enterprise Linux (RHEL).  
   * **Red Hat Linux** (Red Hat Enterprise Linux, RHEL)  
     * **Propósito**: Está diseñado para entornos empresariales con un fuerte enfoque en la estabilidad, seguridad y soporte a largo plazo. Es ampliamente utilizado en servidores y centros de datos.  
2. ¿En qué se diferencia una distribución de otra?

    Las distribuciones de GNU/Linux se diferencian en varios aspectos clave, como:

   * El sistema de gestión de paquetes (por ejemplo, APT para Debian/Ubuntu, DNF para Fedora/Red Hat).  
   * La filosofía y los objetivos del proyecto (como el enfoque en la estabilidad de Debian o la innovación de Fedora).  
   * El entorno de escritorio predeterminado y las aplicaciones incluidas.  
   * Herramientas para la configuración.  
3. ¿Qué es Debian? Acceda al sitio 1 e indique cuáles son los objetivos del proyecto y una breve cronología del mismo

    Debian es una distribución de GNU/Linux y un proyecto de software libre fundado en 1993 por Ian Murdock. Los principales objetivos del proyecto Debian son:

   * Crear un sistema operativo completamente libre y de código abierto.  
   * Mantener un sistema de alta calidad y estabilidad.  
   * Adherirse estrictamente a los principios del software libre.  
4. En cuanto a la cronología, algunos hitos importantes incluyen:

   * 1993: Fundación del proyecto Debian por Ian Murdock.  
   * 1996: Lanzamiento de Debian 1.1, la primera versión estable.  
   * 2005: Lanzamiento de Debian 3.1 (Sarge), que introdujo el instalador gráfico.

### **3\. Estructura de GNU/Linux**

1. Nombre cuales son los 3 componentes fundamentales de GNU/Linux.

    Los tres componentes fundamentales de GNU/Linux son:

   1. El kernel (también conocido como núcleo) es la parte fundamental de un sistema operativo. El kernel o núcleo de linux se podría definir como el corazón de este sistema operativo. Es, a grandes rasgos, el encargado de que el software y el hardware de una computadora puedan trabajar juntos.  
   2. El Shell (intérprete de comandos) es el programa que recibe lo que se escribe en la terminal y lo convierte en instrucciones para el sistema operativo. Un intérprete de comandos es un programa que lee las entradas del usuario y las traduce a instrucciones que el sistema es capaz de entender y utilizar.  
   3. El Filesystem se traduce como “sistema de archivos”; y es la forma en que dentro de un SO se organizan y se administran los archivos.  
2. Mencione y explique la estructura básica del Sistema Operativo GNU/Linux.

    La estructura básica del Sistema Operativo GNU/Linux se compone de varios niveles interconectados. En el nivel más bajo se encuentra el hardware, seguido por el kernel, que actúa como intermediario entre el hardware y el software. Por encima del kernel están las bibliotecas del sistema, que proporcionan funciones básicas para las aplicaciones, y finalmente, en el nivel superior, se encuentran las aplicaciones de usuario y el shell, que permite la interacción directa con el sistema.

### **4\. kernel**

1. ¿Qué es? Indique una breve reseña histórica acerca de la evolución de Kernel de GNU/Linux

    El kernel es una "porcion de código" que se encuentra en memoria principal, y se encarga de la administración de recursos.

    Una breve reseña histórica de la evolución del kernel de GNU/Linux:

   1. 1991: Linus Torvalds crea la primera versión del kernel de Linux como un proyecto personal.  
   2. 1992: El kernel de Linux se combina con el sistema GNU, creando GNU/Linux.  
   3. 1994: Se lanza la versión 1.0 del kernel de Linux, marcando su primera versión estable.  
   4. 1996: Se introduce el soporte para múltiples arquitecturas de procesadores.  
   5. 2001: Se lanza la versión 2.4, que mejora el soporte para sistemas multiprocesador y añade nuevos sistemas de archivos.  
   6. 2003: Se introduce la versión 2.6, que mejora la escalabilidad y el rendimiento.  
   7. 2011: Se lanza la versión 3.0, principalmente por razones de numeración.  
   8. 2015: Se lanza la versión 4.0, que introduce nuevas características de seguridad y mejoras en el rendimiento.  
   9. 2019 en adelante: Continúan las actualizaciones regulares, mejorando el soporte para nuevo hardware, la seguridad y el rendimiento.  
2. ¿Cuáles son sus funciones principales?

   1. Manejo de memoria  
   2. Manejo de la CPU  
   3. Administración de procesos  
   4. Comunicación y concurrencia  
   5. Gestión de E/S  
3. ¿Cuál es la versión actual? ¿Cómo se definía el esquema de versionado del Kernel en versiones anteriores a la 2.4? ¿Qué cambió en el versionado se impuso a partir de la versión 2.6?

    La versión actual del kernel de Linux es **6.10.7.**

    Antes de la versión 2.4, el esquema de versionado del kernel de Linux seguía una convención de tres números: **X.Y.Z**.

   1. **X**: Indica la versión principal o mayor (major).  
   2. **Y**: Indica la versión menor (minor).  
   3. **Z**: Indica una versión de corrección o parche (patch).  
4. El número **Y** también indicaba si la versión era estable o en desarrollo:

   1. **Y** par: Versión estable (por ejemplo, 1.2).  
   2. **Y** impar: Versión en desarrollo o experimental (por ejemplo, 1.3).  
5. Con el lanzamiento de la versión 2.6 en diciembre de 2003, el esquema de versionado cambió significativamente:

   1. **X.Y**: Se mantuvo, pero ya no se utilizó la convención de números pares/impares para indicar estabilidad o desarrollo. Todas las versiones lanzadas eran consideradas estables.  
   2. **Z**: Se utilizó para indicar actualizaciones menores (actualizaciones de mantenimiento) y se agregaron números adicionales (e.g., 2.6.12).  
   3. A partir de la versión 2.6, se dejó de lanzar nuevas versiones principales (por ejemplo, 3.0) por muchos años, enfocándose en actualizaciones incrementales.  
6. Este enfoque se mantuvo hasta que, en 2011, se decidió avanzar a la versión 3.x y luego a la 4.x, pero el esquema de versionado mantuvo un ritmo más rápido y simplificado, con cada nueva versión principal lanzada aproximadamente cada 9 a 10 semanas.

7. ¿Es posible tener más de un Kernel de GNU/Linux instalado en la misma máquina?

    Sí, es posible tener más de un kernel de GNU/Linux instalado en la misma máquina. Esto se conoce como "multi-boot" o arranque múltiple. Los usuarios avanzados a menudo mantienen múltiples versiones del kernel por razones de compatibilidad, pruebas o como respaldo en caso de que una nueva versión presente problemas.

    La gestión de múltiples kernels se realiza generalmente a través del gestor de arranque, como GRUB, que permite seleccionar qué kernel cargar durante el inicio del sistema.

8. ¿Dónde se encuentra ubicado dentro del File System?

    El kernel de Linux se encuentra típicamente ubicado en el directorio /boot del sistema de archivos. Los archivos del kernel suelen tener nombres que comienzan con "vmlinuz", seguidos por la versión del kernel. Por ejemplo, /boot/vmlinuz-6.10.7-generic.

    Además de la imagen del kernel, en este directorio también se encuentran archivos relacionados como el initramfs (imagen inicial del sistema de archivos en RAM) y el archivo de configuración del kernel.

9. ¿El Kernel de GNU/Linux es monolítico? Justifique.

    Sí, el kernel de GNU/Linux es considerado monolítico. Esto significa que todo el código del kernel se ejecuta en un solo espacio de memoria con privilegios completos. A pesar de ser monolítico, el kernel de Linux incorpora características modulares que le permiten cargar y descargar funcionalidades dinámicamente, lo que combina la eficiencia de un kernel monolítico con la flexibilidad de un diseño modular.

### **5\. Intérprete de comandos (shell)**

1. ¿Qué es?

    Un intérprete de comandos, también conocido como shell, es un programa que proporciona una interfaz de usuario para acceder a los servicios del sistema operativo. Actúa como un intermediario entre el usuario y el kernel, interpretando los comandos ingresados por el usuario y traduciéndolos en instrucciones que el sistema operativo puede ejecutar. El shell también ofrece características como la ejecución de scripts, la redirección de entrada/salida y la gestión de procesos, lo que facilita la interacción con el sistema y la automatización de tareas.

2. ¿Cuáles son sus funciones?

    Las principales funciones de un intérprete de comandos (shell) incluyen:

   1. Interpretación de comandos: Lee y ejecuta los comandos ingresados por el usuario.  
   2. Ejecución de programas: Inicia y gestiona la ejecución de otros programas y procesos.  
   3. Redirección de entrada/salida: Permite redirigir la entrada y salida de los comandos y programas.  
3. Mencione al menos 3 intérpretes de comandos que posee GNU/Linux y compárelos entre ellos.

    Tres intérpretes de comandos comunes en GNU/Linux son Bash, Zsh y Fish. Aquí se comparan brevemente:

   1. Bash (Bourne Again Shell): Es el shell predeterminado en la mayoría de las distribuciones Linux. Ofrece una amplia compatibilidad, scripting potente y una gran cantidad de documentación disponible.  
   2. Zsh (Z Shell): Extiende muchas características de Bash, añadiendo mejoras como autocompletado más avanzado, corrección ortográfica y temas personalizables. Es altamente configurable y popular entre usuarios avanzados.  
   3. Fish (Friendly Interactive Shell): Diseñado para ser más amigable para el usuario, con características como sugerencias basadas en el historial, resaltado de sintaxis y autocompletado web. Es menos compatible con scripts de Bash, pero ofrece una experiencia más moderna y fácil de usar.  
4. ¿Dónde se ubican (path) los comandos propios y externos al Shell?

    Los comandos en un sistema GNU/Linux se ubican en diferentes directorios según su tipo:

   1. Comandos propios del shell (built-in): Estos están integrados en el propio shell y no tienen una ubicación física en el sistema de archivos.  
   2. Comandos externos: Se encuentran en varios directorios del sistema, principalmente en /bin, /usr/bin, /sbin, y /usr/sbin. El shell usa la variable de entorno PATH para buscar estos comandos en los directorios especificados.  
5. ¿Por qué considera que el Shell no es parte del Kernel de GNU/Linux?

    El Shell no es parte del kernel de GNU/Linux por varias razones importantes. En primer lugar, el kernel y el shell tienen funciones y niveles de operación distintos: el kernel opera a nivel del sistema, mientras que el shell funciona a nivel de usuario. Además, el shell es un programa reemplazable y configurable, lo que permite a los usuarios elegir diferentes shells según sus preferencias, sin afectar el funcionamiento fundamental del sistema operativo. Esta separación promueve la modularidad y flexibilidad del sistema GNU/Linux, permitiendo que el kernel y el shell evolucionen de manera independiente.

6. ¿Es posible definir un intérprete de comandos distinto para cada usuario? ¿Desde dónde se define? ¿Cualquier usuario puede realizar dicha tarea?

    Sí, es posible definir un intérprete de comandos distinto para cada usuario en GNU/Linux. Esto se define generalmente en el archivo /etc/passwd, donde se especifica el shell predeterminado para cada usuario. Sin embargo, no cualquier usuario puede realizar esta tarea; normalmente, solo el usuario root o aquellos con privilegios de administrador pueden modificar este archivo y cambiar el shell de un usuario.

### **6\. Sistema de Archivos (File System)**

1. ¿Qué es?

    Un sistema de archivos (File System) es una estructura y método de organización que el sistema operativo utiliza para controlar cómo se almacenan y recuperan los datos en dispositivos de almacenamiento. Define cómo se nombran, almacenan y organizan los archivos, así como cómo se gestionan los metadatos asociados a estos archivos. El sistema de archivos proporciona una abstracción que permite a los usuarios y aplicaciones interactuar con los archivos de manera lógica y coherente, independientemente de la estructura física del dispositivo de almacenamiento subyacente.

2. Mencione sistemas de archivos soportados por GNU/Linux

    GNU/Linux soporta una amplia variedad de sistemas de archivos. Algunos de los más comunes incluyen:

   * ext4: El sistema de archivos predeterminado en la mayoría de las distribuciones Linux modernas.  
   * ext3 y ext2: Versiones anteriores del sistema de archivos ext, aún soportadas por compatibilidad.  
   * XFS: Un sistema de archivos de alto rendimiento, especialmente para grandes volúmenes.  
3. ¿Es posible visualizar particiones del tipo FAT y NTFS en GNU/Linux?

    Sí, es posible visualizar particiones del tipo FAT y NTFS en GNU/Linux. El kernel de Linux incluye soporte para leer y escribir en estos sistemas de archivos, que son comúnmente utilizados en sistemas Windows. Para FAT, el soporte es nativo y generalmente no requiere configuración adicional. Para NTFS, aunque el soporte de lectura es nativo, el soporte completo de escritura puede requerir la instalación de controladores adicionales como NTFS-3G en algunas distribuciones.

4. ¿Cuál es la estructura básica de los File System en GNU/Linux? Mencione los directorios más importantes e indique qué tipo de información se encuentra en ellos. ¿A qué hace referencia la sigla FHS?

    La estructura básica del sistema de archivos en GNU/Linux sigue el Filesystem Hierarchy Standard (FHS), que define la estructura de directorios y el contenido de los sistemas Unix y similares. Los directorios más importantes incluyen:

   * /: El directorio raíz, que contiene todos los demás directorios.  
   * /etc: Archivos de configuración del sistema.  
   * /home: Directorios personales de los usuarios.  
   * /bin y /sbin: Comandos esenciales del sistema.  
   * /var: Datos variables como logs y archivos temporales.  
5. La sigla FHS hace referencia al Filesystem Hierarchy Standard, que es un conjunto de directrices que definen la estructura de directorios y su contenido en sistemas operativos Linux y otros sistemas tipo Unix.

### **7\. Particiones**

1. Definición. Tipos de particiones. Ventajas y Desventajas.

    Una partición es una división lógica de un disco duro o una unidad de almacenamiento. Permite que un solo disco físico se divida en varias unidades independientes, cada una con su propio sistema de archivos1.

    **Tipos de Particiones**

   2. **Partición Primaria**: Es la partición principal que puede contener un sistema operativo. Un disco puede tener hasta cuatro particiones primarias2.  
   3. **Partición Extendida**: Esta partición no puede contener datos directamente, pero puede albergar múltiples particiones lógicas. Solo se puede tener una partición extendida por disco2.  
   4. **Partición Lógica**: Se encuentra dentro de una partición extendida y se utiliza para almacenar datos. No puede contener un sistema operativo directamente2.  
   5. **Partición de Arranque**: Contiene los archivos necesarios para iniciar el sistema operativo[2](https://tiposde.net/tipos-de-particiones/).  
   6. **Partición de Recuperación**: Se utiliza para restaurar el sistema operativo en caso de fallos2.  
   7. **Partición de Datos**: Exclusivamente para almacenar datos como documentos, imágenes y videos[2](https://tiposde.net/tipos-de-particiones/).  
   8. **Partición de Intercambio (Swap)**: Utilizada en sistemas Linux para gestionar la memoria virtual2.  
2. **Ventajas**

   2. **Organización**: Facilita la organización de datos y sistemas operativos.  
   3. **Seguridad**: Mejora la seguridad al aislar diferentes tipos de datos.  
   4. **Rendimiento**: Puede mejorar el rendimiento del sistema al separar el sistema operativo de los datos.  
   5. **Recuperación**: Facilita la recuperación del sistema en caso de fallos1.  
3. **Desventajas**

   2. **Complejidad**: Puede ser complicado de gestionar para usuarios inexpertos.  
   3. **Espacio**: La creación de múltiples particiones puede desperdiciar espacio si no se gestionan adecuadamente.  
   4. **Limitaciones**: Algunas particiones tienen limitaciones en cuanto al número y tamaño  
4. ¿Cómo se identifican las particiones en GNU/Linux? (Considere discos IDE, SCSI ySATA)

    En GNU/Linux, puedes identificar las particiones de discos IDE, SCSI y SATA utilizando varios comandos en la terminal. Aquí te explico algunos de los más comunes:

    Comandos para Identificar Particiones:

   2. **lsblk**: Este comando lista todos los dispositivos de bloque, incluyendo discos y particiones.

       `sudo lsblk`

   3. **fdisk**: Muestra la tabla de particiones de un disco específico. Es útil para ver detalles de particiones en discos IDE, SCSI y SATA.

       `sudo fdisk -l`

   4. **blkid**: Muestra información sobre los dispositivos de bloque, incluyendo UUID y tipo de sistema de archivos.

       `sudo blkid`

   5. **parted**: Es una herramienta avanzada para gestionar particiones. Puedes usarla para listar particiones y obtener información detallada.

       `sudo parted -l`

   6. **lsscsi**: Lista todos los dispositivos SCSI, incluyendo discos SATA y SCSI.

       `sudo lsscsi`

5. ¿Cuántas particiones son necesarias como mínimo para instalar GNU/Linux? Nómbrelas indicando tipo de partición, identificación, tipo de File System y punto de montaje.

    Para instalar GNU/Linux, se necesitan al menos dos particiones.

   2. Partición Root (/)  
   3. **Tipo de Partición**: Primaria  
   4. **Identificación**: **`/dev/sda1`** (puede variar)  
   5. **Tipo de File System**: Ext4 (comúnmente utilizado)  
   6. **Punto de Montaje**: **`/`**  
   7. Partición Swap  
   8. **Tipo de Partición**: Primaria o Lógica  
   9. **Identificación**: **`/dev/sda2`** (puede variar)  
   10. **Tipo de File System**: Swap  
   11. **Punto de Montaje**: No tiene punto de montaje, se utiliza como memoria virtual  
6. Ejemplifique diversos casos de particionamiento dependiendo del tipo de tarea que se deba realizar en su sistema operativo.

    **1\. Sistema de Escritorio con Separación de Datos**

    Para un sistema de escritorio donde se desea separar los datos personales del sistema operativo:

   2. **Root (/)**  
      * **Tipo de Partición**: Primaria  
      * **Identificación**: **`/dev/sda1`**  
      * **Tipo de File System**: Ext4  
      * **Punto de Montaje**: **`/`**  
   3. **Home (/home)**  
      * **Tipo de Partición**: Primaria o Lógica  
      * **Identificación**: **`/dev/sda3`**  
      * **Tipo de File System**: Ext4  
      * **Punto de Montaje**: **`/home`**  
   4. **Swap**  
      * **Tipo de Partición**: Primaria o Lógica  
      * **Identificación**: **`/dev/sda2`**  
      * **Tipo de File System**: Swap  
      * **Punto de Montaje**: No aplica  
7. **2\. Servidor Web**

    Para un servidor web, es útil tener particiones separadas para el sistema operativo, los datos del servidor y los registros:

   2. **Root (/)**  
      * **Tipo de Partición**: Primaria  
      * **Identificación**: **`/dev/sda1`**  
      * **Tipo de File System**: Ext4  
      * **Punto de Montaje**: **`/`**  
   3. **Home (/home)**  
      * **Tipo de Partición**: Primaria o Lógica  
      * **Identificación**: **`/dev/sda3`**  
      * **Tipo de File System**: Ext4  
      * **Punto de Montaje**: **`/home`**  
   4. **Var (/var)**  
      * **Tipo de Partición**: Primaria o Lógica  
      * **Identificación**: **`/dev/sda4`**  
      * **Tipo de File System**: Ext4  
      * **Punto de Montaje**: **`/var`**  
   5. **Swap**  
      * **Tipo de Partición**: Primaria o Lógica  
      * **Identificación**: **`/dev/sda2`**  
      * **Tipo de File System**: Swap  
      * **Punto de Montaje**: No aplica  
8. **3\. Sistema de Desarrollo**

    Para un sistema de desarrollo, se puede añadir una partición para los proyectos:

   2. **Root (/)**  
      * **Tipo de Partición**: Primaria  
      * **Identificación**: **`/dev/sda1`**  
      * **Tipo de File System**: Ext4  
      * **Punto de Montaje**: **`/`**  
   3. **Home (/home)**  
      * **Tipo de Partición**: Primaria o Lógica  
      * **Identificación**: **`/dev/sda3`**  
      * **Tipo de File System**: Ext4  
      * **Punto de Montaje**: **`/home`**  
   4. **Var (/var)**  
      * **Tipo de Partición**: Primaria o Lógica  
      * **Identificación**: **`/dev/sda4`**  
      * **Tipo de File System**: Ext4  
      * **Punto de Montaje**: **`/var`**  
   5. **Projects (/projects)**  
      * **Tipo de Partición**: Primaria o Lógica  
      * **Identificación**: **`/dev/sda5`**  
      * **Tipo de File System**: Ext4  
      * **Punto de Montaje**: **`/projects`**  
   6. **Swap**  
      * **Tipo de Partición**: Primaria o Lógica  
      * **Identificación**: **`/dev/sda2`**  
      * **Tipo de File System**: Swap  
      * **Punto de Montaje**: No aplica  
9. ¿Qué tipo de software para particionar existe? Menciónelos y compare.

    algunos de los más populares:

   2. **MiniTool Partition Wizard Free**:  
      * **Pros**: Soporte para una amplia gama de tareas de particionado, interfaz intuitiva, permite extender la partición del sistema sin reiniciar.  
      * **Contras**: Algunas características avanzadas solo están disponibles en la versión de pago.  
   3. **AOMEI Partition Assistant Standard Edition**:  
      * **Pros**: Incluye un asistente paso a paso fácil de usar, permite realizar cambios sin aplicarlos inmediatamente.  
      * **Contras**: Algunas funciones avanzadas requieren la versión Pro.  
   4. **EaseUS Partition Master Free**:  
      * **Pros**: Interfaz amigable, permite clonar discos y particiones, soporte para recuperación de particiones.  
      * **Contras**: La versión gratuita tiene limitaciones en comparación con la versión Pro.  
   5. **GParted**:  
      * **Pros**: Software de código abierto, muy potente y flexible, compatible con múltiples sistemas de archivos.  
      * **Contras**: Interfaz menos amigable para usuarios novatos.  
   6. **NIUBI Partition Editor Free**:  
      * **Pros**: Rápido y seguro, permite reducir, ampliar, mover y fusionar particiones, optimiza el espacio en disco.  
      * **Contras**: Algunas funciones avanzadas solo están disponibles en la versión de pago.

### **8\. Arranque (bootstrap) de un sistema operativo**

1. ¿Qué es el BIOS? ¿Qué tarea realiza?

    El BIOS (Basic Input/Output System) es un firmware esencial que se encuentra en la placa madre de una computadora. Su tarea principal es inicializar y probar el hardware del sistema durante el proceso de arranque, conocido como POST (Power-On Self-Test). Además, el BIOS proporciona una interfaz de bajo nivel para el sistema operativo, permitiéndole interactuar con los componentes de hardware básicos como el teclado, la pantalla y los dispositivos de almacenamiento.

2. ¿Qué es UEFI? ¿Cuál es su función?

    UEFI (Unified Extensible Firmware Interface) es un sucesor moderno del BIOS tradicional. Su función principal es inicializar el hardware del sistema y cargar el sistema operativo, pero lo hace de una manera más avanzada y flexible que el BIOS. UEFI ofrece características mejoradas como tiempos de arranque más rápidos, soporte para discos duros de más de 2 TB, una interfaz gráfica más amigable y capacidades de red y seguridad integradas. Además, UEFI proporciona un entorno de pre-arranque más robusto que permite la ejecución de aplicaciones y diagnósticos antes de que se cargue el sistema operativo.

3. ¿Qué es el MBR? ¿Qué es el MBC?

    MBR (Master Boot Record) es una estructura de datos especial ubicada en el primer sector de un disco duro. Contiene información sobre cómo están organizadas las particiones en el disco y un pequeño programa llamado bootloader que inicia el proceso de arranque del sistema operativo. El MBR es crucial para el arranque de sistemas basados en BIOS.

    Por otro lado, MBC (Master Boot Code) se refiere al código de arranque maestro, que es una parte específica del MBR. Es el programa pequeño mencionado anteriormente que se ejecuta cuando la computadora arranca y es responsable de cargar el sistema operativo.

4. ¿A qué hacen referencia las siglas GPT? ¿Qué sustituye? Indique cuál es su formato.

    GPT (GUID Partition Table) es un estándar para la disposición de la tabla de particiones en un disco duro físico. Sustituye al esquema de particionado MBR (Master Boot Record) tradicional. El formato de GPT utiliza identificadores únicos globales (GUIDs) para definir las particiones y proporciona una mayor flexibilidad y capacidad de almacenamiento. A diferencia del MBR que está limitado a 4 particiones primarias y discos de hasta 2 TB, GPT permite hasta 128 particiones primarias y soporta discos de tamaños mucho mayores, teóricamente hasta 9.4 ZB (zetabytes).

5. ¿Cuál es la funcionalidad de un “Gestor de Arranque”? ¿Qué tipos existen? ¿Dónde se instalan? Cite gestores de arranque conocidos.

    Un Gestor de Arranque, también conocido como bootloader, es un programa que se encarga de cargar el sistema operativo cuando se inicia la computadora. Su funcionalidad principal es proporcionar al usuario opciones para elegir qué sistema operativo arrancar en caso de que haya varios instalados. Existen dos tipos principales de gestores de arranque: los que se instalan en el MBR (Master Boot Record) para sistemas basados en BIOS, y los que se instalan en la partición EFI para sistemas basados en UEFI.

    Los gestores de arranque se instalan típicamente en el sector de arranque del disco duro o en una partición especial, dependiendo del tipo de firmware del sistema (BIOS o UEFI). Algunos gestores de arranque conocidos incluyen GRUB (Grand Unified Bootloader), que es ampliamente utilizado en sistemas Linux, LILO (Linux Loader), que fue popular en versiones anteriores de Linux, y el Gestor de Arranque de Windows, que viene preinstalado en sistemas Windows.

6. ¿Cuáles son los pasos que se suceden desde que se prende una computadora hasta que el Sistema Operativo es cargado (proceso de bootstrap)?

    El proceso de bootstrap, también conocido como secuencia de arranque, consta de varios pasos desde que se enciende una computadora hasta que el sistema operativo se carga completamente. Estos pasos incluyen la inicialización del hardware por el BIOS o UEFI, la ejecución del POST (Power-On Self-Test), la carga del gestor de arranque desde el MBR o la partición EFI, y finalmente la carga del kernel del sistema operativo. Durante este proceso, el control se transfiere gradualmente desde el firmware del sistema hasta el sistema operativo, permitiendo que la computadora esté lista para su uso.

7. Analice el proceso de arranque en GNU/Linux y describa sus principales pasos.

    El proceso de arranque en GNU/Linux consta de varios pasos principales:

   1. Inicio del hardware y BIOS/UEFI: Al encender la computadora, el BIOS o UEFI realiza el POST y localiza el dispositivo de arranque.  
   2. Carga del gestor de arranque: Generalmente GRUB2, que se carga desde el MBR o la partición EFI.  
   3. Selección del kernel: GRUB2 presenta un menú para elegir el kernel y opciones de arranque.  
   4. Carga del kernel: El kernel seleccionado se carga en memoria y se descomprime si es necesario.  
   5. Inicialización del kernel: El kernel configura el hardware y monta el sistema de archivos raíz.  
   6. Ejecución de init o systemd: El primer proceso del espacio de usuario se inicia, gestionando los demás servicios del sistema.  
8. ¿Cuáles son los pasos que se suceden en el proceso de parada (shutdown) de GNU/Linux?

   1. **Notificación a los usuarios**:  
      * Se envía un mensaje a todos los usuarios conectados informándoles del apagado inminente. Esto les da tiempo para guardar su trabajo y cerrar sus sesiones.  
   2. **Bloqueo de nuevos inicios de sesión**:  
      * Se impide que nuevos usuarios inicien sesión en el sistema para evitar interrupciones durante el proceso de apagado.  
   3. **Cierre de procesos de usuario**:  
      * Se envía una señal SIGTERM a todos los procesos de usuario para que se cierren de manera ordenada. Si algún proceso no responde, se le envía una señal SIGKILL para forzar su cierre.  
   4. **Sincronización de sistemas de archivos**:  
      * Se sincronizan los sistemas de archivos para asegurarse de que todos los datos pendientes se escriban en el disco, evitando la pérdida de datos.  
   5. **Desmontaje de sistemas de archivos**:  
      * Se desmontan todos los sistemas de archivos montados para evitar daños en los datos.  
   6. **Cierre de servicios del sistema**:  
      * Se detienen todos los servicios del sistema, como servidores web, bases de datos, etc.  
   7. **Apagado del hardware**:  
      * Finalmente, se envía una señal al hardware para cortar la energía y apagar el sistema 1  
9. ¿Es posible tener en una PC GNU/Linux y otro Sistema Operativo instalado? Justifique.

    Sí, es posible tener GNU/Linux y otro sistema operativo instalado en la misma PC. Esto se conoce como arranque dual o "dual boot". Esta configuración permite al usuario elegir qué sistema operativo iniciar cada vez que se enciende la computadora. Para lograr esto, se particiona el disco duro para asignar espacio a cada sistema operativo y se utiliza un gestor de arranque como GRUB para seleccionar el sistema deseado durante el inicio.

### **9\. Archivos**

1. ¿Cómo se identifican los archivos en GNU/Linux?

   * **Nombre del archivo:** Cada archivo tiene un nombre único dentro de su directorio. Puede contener letras, números y algunos caracteres especiales.  
   * **Rutas:** Los archivos se identifican por su ruta dentro del sistema de archivos. Por ejemplo, `/home/usuario/documento.txt` es una ruta absoluta que identifica un archivo específico.  
   * Aunque no es obligatorio, las extensiones (como `.txt`, `.jpg`, `.sh`) suelen indicar el tipo de archivo. Sin embargo, en GNU/Linux, el tipo real de un archivo no depende de la extensión.  
2. Investigue el funcionamiento de los editores vi y mcedit, y los comandos cat y more.

   * **Editor `vi`**  
   * Es uno de los editores de texto más antiguos y tradicionales en Unix y GNU/Linux. Es conocido por su eficiencia y su uso en entornos donde no hay interfaz gráfica disponible.  
   * **Modos de operación**:  
     * **Modo normal**: Es el modo por defecto al abrir `vi`. Permite moverse por el texto y ejecutar comandos.  
     * **Modo de inserción**: Se activa al presionar `i`, `a`, `o`, etc. En este modo, puedes escribir texto.  
     * **Modo de comando**: Se accede presionando `:` desde el modo normal. Aquí puedes ejecutar comandos como guardar (`:w`), salir (`:q`), o buscar (`:/texto`).  
   * **Comandos básicos**:  
     * `:wq` \- Guarda y cierra el archivo.  
     * `:q!` \- Cierra sin guardar.  
     * `dd` \- Elimina una línea.  
     * `yy` \- Copia una línea.  
     * `p` \- Pega después de la línea actual.  
   * **Uso**: `vi nombre_del_archivo` para abrir o crear un archivo.  
   * **Editor `mcedit`**  
   * Es un editor de texto más amigable y fácil de usar, parte del paquete `Midnight Commander (mc)`. Es ideal para usuarios que prefieren una interfaz más intuitiva.  
   * **Características**:  
     * **Interfaz visual**: `mcedit` presenta una interfaz con menús accesibles mediante teclas de función, lo que facilita su uso.  
     * **Operaciones básicas**: Puedes abrir archivos, copiar, cortar, pegar, buscar y reemplazar texto, todo desde una interfaz visual.  
     * **Teclas comunes**:  
       * `F2` \- Guarda el archivo.  
       * `F10` \- Cierra el editor.  
       * `F4` \- Edita el archivo (si estás usando `mc`).  
   * **Uso**: `mcedit nombre_del_archivo` para abrir o crear un archivo.  
   * **Comando `cat`**  
   * El comando `cat` (abreviatura de "concatenate") se utiliza principalmente para mostrar el contenido de archivos en la terminal, concatenar archivos y redirigir su salida.  
   * **Uso común**:  
     * `cat archivo.txt` \- Muestra el contenido de `archivo.txt`.  
     * `cat archivo1.txt archivo2.txt > archivo3.txt` \- Concatenar `archivo1.txt` y `archivo2.txt` en `archivo3.txt`.  
   * **Opciones útiles**:  
     * `cat -n archivo.txt` \- Muestra el contenido de `archivo.txt` con numeración de líneas.  
     * `cat -b archivo.txt` \- Numeración de líneas no vacías.  
   * **Uso**: Es ideal para ver rápidamente el contenido de archivos pequeños o combinar archivos.  
   * **Comando `more`**  
   * `more` es un comando que permite visualizar archivos de texto de manera paginada, útil para archivos grandes.  
   * **Funcionalidad**:  
     * Muestra el contenido de un archivo pantalla por pantalla.  
     * Presiona `Enter` para avanzar una línea, o `Space` para avanzar una página.  
   * **Comandos dentro de `more`**:  
     * `/texto` \- Buscar la siguiente aparición de "texto".  
     * `q` \- Salir de `more`.  
     * `h` \- Muestra ayuda.  
   * **Uso**: `more archivo.txt` para ver un archivo de texto.  
   * Comparación:  
   * **`vi` vs `mcedit`**: `vi` es más potente y eficiente para usuarios experimentados, mientras que `mcedit` es más fácil de aprender y usar para tareas básicas.  
   * **`cat` vs `more`**: `cat` muestra todo el contenido del archivo de una vez, mientras que `more` lo hace de manera paginada, lo que es útil para archivos grandes.  
3. Cree un archivo llamado “prueba.exe” en su directorio personal usando el vi. El mismo debe contener su número de alumno y su nombre.

   * vi para abrir el editor  
   * ”i” para activar el modo insertar  
   * escribo los datos  
   * “esc \+ shift \+ :” y escribimos wq para cerrar y guardar el archivo  
4. y así tendremos nuestro archivo creado en el directorio /home/usuarioPersonal

5. Investigue el funcionamiento del comando file. Pruébelo con diferentes archivos. ¿Qué diferencia nota? El comando `file` en GNU/Linux se utiliza para determinar el tipo de un archivo examinando su contenido en lugar de confiar en la extensión del archivo. Esto es útil para identificar correctamente archivos que pueden no tener una extensión o que pueden haber sido renombrados incorrectamente.

   * **Diferencias Notadas**  
     * **Precisión del tipo de archivo:** El comando `file` identifica el tipo de archivo basado en su contenido, no en su extensión. Esto significa que incluso si cambias la extensión de un archivo de `.txt` a `.jpg`, `file` seguirá reconociendo que es un archivo de texto.  
     * **Detección de formato específico:** `file` puede identificar no solo el tipo genérico del archivo (por ejemplo, texto, imagen, comprimido), sino también detalles específicos, como la codificación de texto o el formato exacto de la imagen.  
     * **Versatilidad:** El comando es capaz de manejar una amplia variedad de formatos, desde archivos de texto y binarios hasta imágenes, archivos de audio, videos y más

### **10\. Indique qué comando es necesario utilizar para realizar cada una de las siguientes acciones. Investigue su funcionamiento y parámetros más importantes:**

1. Cree la carpeta ISO2017 (mkdir)

   * `mkdir ISO2017`  
   * `mkdir` crea un directorio  
   * Parámetros más importantes  
     * `-p` **(padres):** crea también los directorios padres si no existen  
     * `-v` **(verbose):** muestra un mensaje por cada directorio creado  
     * **`-m` (modo/permisos)**: Establece los permisos al crear el directorio.  
2. Acceda a la carpeta (cd)

   * `cd ISO2017`  
   * `cd` (change directory) cambia el directorio de trabajo actual al directorio especificado.  
   * Parámetros más importantes  
     * `cd /ruta/completa/a/ISO2017` acceder a un directorio específico por su ruta completa  
     * `cd -` volver al directorio anterior  
     * `cd ..` ir al directorio padre  
     * `cd ~` ir al directorio de inicio del usuario  
3. Cree dos archivos con los nombres iso2017-1 e iso2017-2 (touch)

   * `touch iso2017-1`  
   * `touch iso2017-2`  
   * se utiliza en GNU/Linux para crear archivos vacíos o para actualizar la fecha y hora de modificación de archivos existentes.  
   * Parámetros más importantes  
     * **`-a` (access time)**: Modifica solo la fecha y hora de acceso del archivo.  
     * **`-m` (modification time)**: Modifica solo la fecha y hora de modificación del archivo.  
     * **`-c` (no create)**: No crea el archivo si no existe; solo actualiza la fecha y hora si ya existe.  
     * **`-t` (time)**: Establece una fecha y hora específicas para el archivo.  
4. Liste el contenido del directorio actual (ls)

   * `ls`  
   * En GNU/Linux se utiliza para listar los archivos y directorios contenidos en un directorio.  
   * Parámetros más importantes  
     * **`-l` (long listing format)**: Muestra información detallada de los archivos, como permisos, número de enlaces, propietario, grupo, tamaño, y fecha de modificación.  
     * **`-a` (all files)**: Incluye archivos ocultos (los que empiezan con un punto `.`) en la lista.  
     * **`-h` (human-readable)**: Muestra tamaños de archivo en un formato legible (por ejemplo, KB, MB) cuando se usa junto con `l`.  
     * **`-R` (recursive)**: Lista todos los archivos en subdirectorios también, de forma recursiva.  
     * **`-t` (sort by time)**: Ordena la lista según la fecha de modificación, mostrando los archivos modificados más recientemente primero.  
5. Visualizar la ruta donde estoy situado (pwd)

   * `pwd`  
   * En GNU/Linux se utiliza para mostrar la ruta completa del directorio en el que te encuentras actualmente. Es útil para orientarte dentro del sistema de archivos.  
   * Parámetros más importantes  
     * **`-l` (logical)**: Muestra la ruta lógica, teniendo en cuenta enlaces simbólicos. Este es el comportamiento por defecto.  
     * **`-p` (physical)**: Muestra la ruta física del directorio, resolviendo enlaces simbólicos. Es decir, te muestra la verdadera ubicación en el sistema de archivos, ignorando cualquier enlace simbólico.  
6. Busque todos los archivos en los que su nombre contiene la cadena “iso\*” (find)

   * `find . -name "iso*”`  
   * En GNU/Linux se utiliza para buscar archivos y directorios en una jerarquía de directorios basada en criterios específicos. Puedes usar `find` para buscar archivos cuyos nombres contienen una cadena específica  
   * Parámetros más importantes  
     * **`-name "patrón"`**: Busca archivos y directorios cuyo nombre coincide con el patrón especificado.  
     * **`-type f`**: Busca solo archivos regulares (excluye directorios).  
     * **`-type d`**: Busca solo directorios.  
     * **`-iname "patrón"`**: Similar a `name`, pero ignora el caso (mayúsculas/minúsculas) en la búsqueda.  
     * **`-maxdepth n`**: Limita la profundidad de búsqueda en la jerarquía de directorios.  
     * **`-mindepth n`**: Establece la profundidad mínima de búsqueda.  
7. Informar la cantidad de espacio libre en disco (df)

   * `df`  
   * `df` (disk free) en GNU/Linux se utiliza para mostrar información sobre el espacio en disco disponible y utilizado en los sistemas de archivos montados.  
   * Parámetros más importantes  
     * **`-h` (human-readable)**: Muestra la información en un formato legible para humanos, utilizando unidades como KB, MB o GB.  
     * **`-H` (human-readable, con potencias de 1000\)**: Similar a `h`, pero utiliza potencias de 1000 en lugar de 1024 para tamaños de disco.  
     * **`-T` (tipo)**: Muestra el tipo de sistema de archivos.  
     * **`-a` (all)**: Muestra información sobre todos los sistemas de archivos, incluidos los que tienen 0 bloques.  
     * **`-i` (inodes)**: Muestra información sobre el uso de inodos en lugar de bloques.  
8. Verifique los usuarios conectado al sistema (who)

   * `who`  
   * En GNU/Linux se utiliza para mostrar una lista de los usuarios que están actualmente conectados al sistema.  
   * Parámetros más importantes  
     * **`-b` (boottime)**: Muestra la hora y fecha del último reinicio del sistema.  
     * **`-q` (quick)**: Muestra solo los nombres de los usuarios conectados y el total de usuarios.  
     * **`-a` (all)**: Muestra información completa sobre todos los registros, incluyendo inicios de sesión y cambios de estado.  
     * **`-H` (header)**: Muestra los encabezados de columna en la salida.  
9. Acceder a el archivo iso2017-1 e ingresar Nombre y Apellido

    Para acceder al archivo iso2017-1 e ingresar Nombre y Apellido, se puede utilizar un editor de texto como nano o vim. Por ejemplo, con el comando:

    `nano iso2017-1`

    Una vez dentro del editor, escribimos nombre y apellido, guardamos los cambios y salimos del editor.

10. Mostrar en pantalla las últimas líneas de un archivo (tail)

    * `tail nombre_del_archivo`  
    * En GNU/Linux se utiliza para mostrar las últimas líneas de un archivo. Es útil para ver la parte final de archivos grandes o para supervisar archivos de registro en tiempo real.  
    * Parámetros más importantes  
      * **`-n [número]`**: Especifica el número de líneas que deseas ver desde el final del archivo.  
      * **`-f` (follow)**: Muestra las nuevas líneas a medida que se añaden al archivo. Es útil para monitorear archivos de registro en tiempo real.  
      * **`-c [número]`**: Muestra los últimos `número` bytes del archivo en lugar de líneas.  
      * **`-q` (quiet)**: Suprime los encabezados de los archivos cuando se especifican múltiples archivos.

### **11\. Investigue su funcionamiento y parámetros más importantes:**

1. `shutdown`

   * El comando `shutdown` se utiliza para apagar o reiniciar el sistema de manera segura.  
   * `shutdown [opciones] [tiempo] [mensaje]`  
   * **Parámetros y Opciones Importantes:**  
     * **`h` (halt)**: Apaga el sistema.  
     * **`r` (reboot)**: Reinicia el sistema.  
     * **`c` (cancel)**: Cancela un apagado o reinicio programado.  
     * **`+m`**: Establece un tiempo para el apagado (en minutos).  
2. `reboot`

   * l comando `reboot` se utiliza para reiniciar el sistema.  
   * **Sin opciones**: Reinicia el sistema inmediatamente.  
   * **`-force`**: Fuerza el reinicio, ignorando algunos controles de seguridad.  
3. `halt`

   * El comando `halt` se utiliza para detener el sistema de manera inmediata.  
   * **Parámetros y Opciones Importantes:**  
     * **Sin opciones**: Detiene el sistema inmediatamente.  
     * **`-force`**: Fuerza el apagado del sistema.  
4. `locate`

   * El comando `locate` se utiliza para buscar archivos en el sistema rápidamente mediante una base de datos indexada.  
   * `locate [opciones] [patrón]`  
   * **Parámetros y Opciones Importantes:**  
     * **Sin opciones**: Busca archivos que coincidan con el patrón dado.  
     * **`-i` (ignore case)**: Ignora el caso en la búsqueda.  
     * **`-r` (regex)**: Usa expresiones regulares para buscar.  
5. `uname`

   * El comando `uname` muestra información sobre el sistema operativo y el kernel.  
   * `uname [opciones]`  
   * **Parámetros y Opciones Importantes:**  
     * **`-a` (all)**: Muestra toda la información disponible.  
     * **`-r` (release)**: Muestra la versión del kernel.  
     * **`-s` (system)**: Muestra el nombre del sistema operativo.  
6. `dmesg`

   * El comando `dmesg` muestra los mensajes del buffer del kernel, que contienen información sobre el arranque del sistema y otros eventos del kernel.  
   * `dmesg [opciones]`  
   * **Parámetros y Opciones Importantes:**  
     * **Sin opciones**: Muestra todos los mensajes del buffer del kernel.  
   * **`-h` (human-readable)**: Muestra los tiempos en un formato legible para humanos.  
   * **`-T` (timestamp)**: Muestra las marcas de tiempo en formato legible.  
7. `lspci`

   * El comando `lspci` muestra información sobre los dispositivos PCI conectados al sistema.  
   * **Parámetros y Opciones Importantes:**  
     * **Sin opciones**: Muestra una lista de dispositivos PCI.  
     * **`-v` (verbose)**: Muestra información detallada.  
     * **`-nn`**: Muestra los identificadores de dispositivo y proveedor en formato numérico.  
8. `at`

   * El comando `at` se utiliza para programar la ejecución de comandos en un momento específico.  
   * **Parámetros y Opciones Importantes:**  
     * **Sin opciones**: Programa una tarea para que se ejecute a la hora especificada.  
     * Después de ejecutar el comando, ingresa el comando que deseas programar y presiona `Ctrl + D` para finalizar.  
     * **`l` (list)**: Muestra las tareas programadas.  
     * **`d` (delete)**: Elimina una tarea programada.  
9. `netstat`

   * El comando `netstat` muestra estadísticas y detalles sobre las conexiones de red y el estado de los puertos.  
   * **Parámetros y Opciones Importantes:**  
     * **`-a` (all)**: Muestra todas las conexiones y puertos de escucha.  
     * **`-t` (TCP)**: Muestra solo conexiones TCP.  
     * **`-u` (UDP)**: Muestra solo conexiones UDP.  
     * **`-l` (listening)**: Muestra solo los puertos en escucha.  
10. `mount`

    * El comando `mount` se utiliza para montar sistemas de archivos en el sistema.  
    * **Parámetros y Opciones Importantes:**  
      * **Sin opciones**: Monta el dispositivo especificado en el punto de montaje.  
      * **`-t` (type)**: Especifica el tipo de sistema de archivos.  
      * **`-o` (options)**: Especifica opciones de montaje, como `rw` (lectura/escritura) o `ro` (solo lectura).  
11. `umount`

    * El comando `umount` se utiliza para desmontar sistemas de archivos.  
    * **Parámetros y Opciones Importantes:**  
      * **Sin opciones**: Desmonta el sistema de archivos especificado.  
      * **`-l` (lazy)**: Desmonta el sistema de archivos de manera perezosa, liberando los recursos cuando ya no estén en uso.  
12. `head`

    * El comando `head` muestra las primeras líneas de un archivo.  
    * **Parámetros y Opciones Importantes:**  
      * **Sin opciones**: Muestra las primeras 10 líneas del archivo.  
      * **`-n [número]`**: Especifica el número de líneas a mostrar desde el inicio del archivo.  
13. `losetup`

    * El comando `losetup` se utiliza para configurar y gestionar dispositivos de bucle (loop devices), que permiten montar archivos como si fueran discos.  
    * `losetup [opciones] [dispositivo] [archivo]`  
    * **Parámetros y Opciones Importantes:**  
      * **`-f` (find)**: Encuentra el primer dispositivo de bucle disponible.  
      * **`-P` (partitions)**: Actualiza la información de partición para el dispositivo de bucle.  
      * **`-d` (detach)**: Desmonta un dispositivo de bucle.  
14. `write`

    * El comando `write` permite enviar mensajes a otros usuarios que están conectados al sistema.  
    * `write [usuario] [punto_de_entrada]`  
    * **Parámetros y Opciones Importantes:**  
      * **Sin opciones**: Envia un mensaje al usuario especificado.  
      * Después de ejecutar el comando, escribe el mensaje y presiona `Ctrl + D` para finalizar el envío.  
15. `mkfs`

    * El comando `mkfs` se utiliza para crear un sistema de archivos en un dispositivo.  
    * `mkfs [opciones] [tipo] [dispositivo]`  
    * **Parámetros y Opciones Importantes:**  
      * **`-t` (type)**: Especifica el tipo de sistema de archivos (como `ext4`, `xfs`, `vfat`).  
      * **`-c` (check)**: Verifica los bloques defectuosos antes de crear el sistema de archivos.  
16. `fdisk`

    * El comando `fdisk` se utiliza para gestionar particiones en discos duros.  
    * `fdisk [opciones] [dispositivo]`  
    * **Parámetros y Opciones Importantes:**  
      * **`-l` (list)**: Muestra la tabla de particiones de todos los discos o del disco especificado.  
      * **Sin opciones**: Inicia el modo interactivo para gestionar particiones.  
17. **Nota:** Usa `fdisk` con cuidado, ya que puede modificar o eliminar particiones y datos.

## **12\. Investigue su funcionamiento y parámetros más importantes:**

1. Indique en qué directorios se almacenan los comandos mencionados en el ejercicio anterior.  
   * **`shutdown`**: `/usr/sbin/shutdown`  
   * **`reboot`**: `/usr/sbin/reboot`  
   * **`halt`**: `/usr/sbin/halt`  
   * **`locate`**: `/usr/bin/locate`  
   * **`uname`**: `/usr/bin/uname`  
   * **`dmesg`**: `/bin/dmesg`  
   * **`lspci`**: `/usr/bin/lspci`  
   * **`at`**: `/usr/bin/at`  
   * **`netstat`**: `/usr/bin/netstat` (En sistemas modernos, este comando es parte del paquete `net-tools`)  
   * **`mount`**: `/usr/bin/mount` o `/bin/mount` (puede variar según la distribución)  
   * **`umount`**: `/usr/bin/umount` o `/bin/umount`  
   * **`head`**: `/usr/bin/head`  
   * **`losetup`**: `/usr/bin/losetup`  
   * **`write`**: `/usr/bin/write`  
   * **`mkfs`**: `/usr/sbin/mkfs`  
   * **`fdisk`**: `/usr/sbin/fdisk`

